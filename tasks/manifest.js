/*
 * grunt-contrib-manifest
 * http://gruntjs.com/
 *
 * Copyright (c) 2012 Tim Branyen, contributors
 * Licensed under the MIT license.
 * https://github.com/gruntjs/grunt-contrib-jst/blob/master/LICENSE-MIT
 */

module.exports = function (grunt) {
  "use strict";

  /* Extracted yeoman-generator/lib/actions/file.js  */
  var fs = require('fs');
  var path = require('path');
  var glob = require('glob');

  // Performs a glob search with the provided `pattern` and optional Hash of
  // `options`. Options can be any option supported by
  // [glob](https://github.com/isaacs/node-glob#options)
  //
  // - pattern  - Glob String pattern to look for
  // - options  - Hash of options matching glob's option.
  //
  // Returns an Array of filenames matching the pattern
  function expand(pattern, options) {
    return glob.sync(pattern, options);
  }

  // Performs a glob search with the provided `pattern` and optional Hash of
  // `options`, filtering results to only return files (not directories). Options
  // can be any option supported by
  // [glob](https://github.com/isaacs/node-glob#options)
  //
  // - pattern  - Glob String pattern to look for
  // - options  - Hash of options matching glob's option.
  //
  // Returns an Array of filenames matching the pattern
  function expandFiles(pattern, options) {
    var cwd = options.cwd || process.cwd();
    if (pattern instanceof Array) {
      var result = [];
      pattern.forEach(function(x){
        result = result.concat(expandFiles(x, options));
      });
      return result;
    } else {
        return expand(pattern, options).filter(function (filepath) {
          return fs.statSync(path.join(cwd, filepath)).isFile();
        });
    }
  }

  grunt.registerMultiTask("manifest", "Generate HTML5 cache manifest", function () {

    var helpers = require("grunt-lib-contrib").init(grunt);
    var options = helpers.options(this, {verbose: true, timestamp:true});

    // If we have a basePath, specify it
    if (this.data.options.basePath) {
      //var base = grunt.file.expandDirs(this.data.options.basePath);
      var base = this.data.options.basePath;
      grunt.file.setBase(base);
    }

    // TODO: ditch this when grunt v0.4 is released
    this.files = this.files || helpers.normalizeMultiTaskFiles(this.data, this.target);

    var verbose = true;
    var done = this.async();
    var files = expandFiles(this.data.src, {});
    var destFile = this.data.dest;
    var contents = "CACHE MANIFEST\n";
    var excludeFiles = options.exclude;
    var cacheFiles = options.cache;

    grunt.verbose.writeflags(options, "Options");

    // "src" is required
    if (!this.data.src) {
      grunt.fatal("Need to specify source directory for the files.", 2);
    }

    // Set default destination file
    if (!destFile) {
      destFile = "manifest.appcache";
    }

    if (options.verbose) {
      contents += "# This manifest was generated by grunt-contrib-manifest HTML5 Cache Manifest Generator\n";
    }
    if (options.timestamp) {
      contents += "# Time: " + new Date() + "\n";
    }

    // Cache section
    contents += "\nCACHE:\n";

    // Exclude files
    if (excludeFiles) {
      files = files.filter(function (item) {
        return excludeFiles.indexOf(item) === -1;
      });
    }

    // Add files to explicit cache manually
    if (cacheFiles) {
      cacheFiles.forEach(function (item) {
        contents += item + "\n";
      });
    }

    // Add files to explicit cache
    if (files) {
      files.forEach(function (item) {
        contents += item + "\n";
      });
    }

    // Network section
    if (options.network) {
      contents += "\nNETWORK:\n";
      options.network.forEach(function (item) {
        contents += item + "\n";
      });
    } else {
      // If there's no network section, add a default "*" wildcard
      contents += "\nNETWORK:\n";
      contents += "*\n";
    }

    // Fallback section
    if (options.fallback) {
      contents += "\nFALLBACK:\n";
      options.fallback.forEach(function (item) {
        contents += item + "\n";
      });
    }

    // Settings section
    if (options.preferOnline) {
      contents += "\nSETTINGS:\n";
      contents += "prefer-online\n";
    }

    // Write file to disk
    grunt.verbose.writeln("\n" + (contents).yellow);
    grunt.file.write(destFile, contents);
    done();
  });

};

